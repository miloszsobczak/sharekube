package resources

import (
	"context"
	"fmt"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"
)

// ResourceHandler handles copying resources between namespaces
type ResourceHandler struct {
	client    client.Client
	dynClient dynamic.Interface
	scheme    *runtime.Scheme
	ownerRef  metav1.OwnerReference
}

// NewResourceHandler creates a new ResourceHandler
func NewResourceHandler(client client.Client, dynClient dynamic.Interface, scheme *runtime.Scheme, ownerRef metav1.OwnerReference) *ResourceHandler {
	return &ResourceHandler{
		client:    client,
		dynClient: dynClient,
		scheme:    scheme,
		ownerRef:  ownerRef,
	}
}

// CopyResource copies a resource from source to target namespace
func (h *ResourceHandler) CopyResource(ctx context.Context, kind, name, sourceNamespace, targetNamespace string) error {
	logger := log.FromContext(ctx)
	logger.Info("Copying resource", "Kind", kind, "Name", name, "From", sourceNamespace, "To", targetNamespace)

	// Handle different resource types
	switch kind {
	case "Deployment":
		return h.copyDeployment(ctx, name, sourceNamespace, targetNamespace)
	case "Service":
		return h.copyService(ctx, name, sourceNamespace, targetNamespace)
	case "ConfigMap":
		return h.copyConfigMap(ctx, name, sourceNamespace, targetNamespace)
	case "Secret":
		return h.copySecret(ctx, name, sourceNamespace, targetNamespace)
	default:
		return h.copyGenericResource(ctx, kind, name, sourceNamespace, targetNamespace)
	}
}

// copyDeployment copies a Deployment resource
func (h *ResourceHandler) copyDeployment(ctx context.Context, name, sourceNamespace, targetNamespace string) error {
	logger := log.FromContext(ctx)

	// Get the source deployment
	srcDeploy := &appsv1.Deployment{}
	if err := h.client.Get(ctx, client.ObjectKey{Namespace: sourceNamespace, Name: name}, srcDeploy); err != nil {
		logger.Error(err, "Failed to get source Deployment")
		return err
	}

	// Create a new deployment for the target
	newDeploy := &appsv1.Deployment{
		ObjectMeta: metav1.ObjectMeta{
			Name:            srcDeploy.Name,
			Namespace:       targetNamespace,
			Labels:          srcDeploy.Labels,
			Annotations:     srcDeploy.Annotations,
			OwnerReferences: []metav1.OwnerReference{h.ownerRef},
		},
		Spec: srcDeploy.Spec,
	}

	// Add label to track resources created by ShareKube
	if newDeploy.Labels == nil {
		newDeploy.Labels = make(map[string]string)
	}
	newDeploy.Labels["sharekube.dev/copied"] = "true"
	newDeploy.Labels["sharekube.dev/source-namespace"] = sourceNamespace

	// Remove resource version from metadata
	newDeploy.ResourceVersion = ""

	// Create the deployment in the target namespace
	if err := h.client.Create(ctx, newDeploy); err != nil {
		logger.Error(err, "Failed to create Deployment in target namespace")
		return err
	}

	logger.Info("Successfully copied Deployment", "Name", name)
	return nil
}

// copyService copies a Service resource
func (h *ResourceHandler) copyService(ctx context.Context, name, sourceNamespace, targetNamespace string) error {
	logger := log.FromContext(ctx)

	// Get the source service
	srcSvc := &corev1.Service{}
	if err := h.client.Get(ctx, client.ObjectKey{Namespace: sourceNamespace, Name: name}, srcSvc); err != nil {
		logger.Error(err, "Failed to get source Service")
		return err
	}

	// Create a new service for the target
	newSvc := &corev1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name:            srcSvc.Name,
			Namespace:       targetNamespace,
			Labels:          srcSvc.Labels,
			Annotations:     srcSvc.Annotations,
			OwnerReferences: []metav1.OwnerReference{h.ownerRef},
		},
		Spec: srcSvc.Spec,
	}

	// Add label to track resources created by ShareKube
	if newSvc.Labels == nil {
		newSvc.Labels = make(map[string]string)
	}
	newSvc.Labels["sharekube.dev/copied"] = "true"
	newSvc.Labels["sharekube.dev/source-namespace"] = sourceNamespace

	// Remove resource version from metadata
	newSvc.ResourceVersion = ""

	// Remove cluster IP and other cluster-specific fields that should be generated by the cluster
	newSvc.Spec.ClusterIP = ""
	newSvc.Spec.ClusterIPs = nil

	// Create the service in the target namespace
	if err := h.client.Create(ctx, newSvc); err != nil {
		logger.Error(err, "Failed to create Service in target namespace")
		return err
	}

	logger.Info("Successfully copied Service", "Name", name)
	return nil
}

// copyConfigMap copies a ConfigMap resource
func (h *ResourceHandler) copyConfigMap(ctx context.Context, name, sourceNamespace, targetNamespace string) error {
	logger := log.FromContext(ctx)

	// Get the source configmap
	srcCm := &corev1.ConfigMap{}
	if err := h.client.Get(ctx, client.ObjectKey{Namespace: sourceNamespace, Name: name}, srcCm); err != nil {
		logger.Error(err, "Failed to get source ConfigMap")
		return err
	}

	// Create a new configmap for the target
	newCm := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:            srcCm.Name,
			Namespace:       targetNamespace,
			Labels:          srcCm.Labels,
			Annotations:     srcCm.Annotations,
			OwnerReferences: []metav1.OwnerReference{h.ownerRef},
		},
		Data:       srcCm.Data,
		BinaryData: srcCm.BinaryData,
	}

	// Add label to track resources created by ShareKube
	if newCm.Labels == nil {
		newCm.Labels = make(map[string]string)
	}
	newCm.Labels["sharekube.dev/copied"] = "true"
	newCm.Labels["sharekube.dev/source-namespace"] = sourceNamespace

	// Remove resource version from metadata
	newCm.ResourceVersion = ""

	// Create the configmap in the target namespace
	if err := h.client.Create(ctx, newCm); err != nil {
		logger.Error(err, "Failed to create ConfigMap in target namespace")
		return err
	}

	logger.Info("Successfully copied ConfigMap", "Name", name)
	return nil
}

// copySecret copies a Secret resource
func (h *ResourceHandler) copySecret(ctx context.Context, name, sourceNamespace, targetNamespace string) error {
	logger := log.FromContext(ctx)

	// Get the source secret
	srcSecret := &corev1.Secret{}
	if err := h.client.Get(ctx, client.ObjectKey{Namespace: sourceNamespace, Name: name}, srcSecret); err != nil {
		logger.Error(err, "Failed to get source Secret")
		return err
	}

	// Create a new secret for the target
	newSecret := &corev1.Secret{
		ObjectMeta: metav1.ObjectMeta{
			Name:            srcSecret.Name,
			Namespace:       targetNamespace,
			Labels:          srcSecret.Labels,
			Annotations:     srcSecret.Annotations,
			OwnerReferences: []metav1.OwnerReference{h.ownerRef},
		},
		Type:       srcSecret.Type,
		Data:       srcSecret.Data,
		StringData: srcSecret.StringData,
	}

	// Add label to track resources created by ShareKube
	if newSecret.Labels == nil {
		newSecret.Labels = make(map[string]string)
	}
	newSecret.Labels["sharekube.dev/copied"] = "true"
	newSecret.Labels["sharekube.dev/source-namespace"] = sourceNamespace

	// Remove resource version from metadata
	newSecret.ResourceVersion = ""

	// Create the secret in the target namespace
	if err := h.client.Create(ctx, newSecret); err != nil {
		logger.Error(err, "Failed to create Secret in target namespace")
		return err
	}

	logger.Info("Successfully copied Secret", "Name", name)
	return nil
}

// copyGenericResource copies an arbitrary resource type using dynamic client
func (h *ResourceHandler) copyGenericResource(ctx context.Context, kind, name, sourceNamespace, targetNamespace string) error {
	logger := log.FromContext(ctx)
	logger.Info("Copying generic resource", "Kind", kind, "Name", name)

	// Determine the GVR for the kind
	gvr, err := getGVRForKind(kind)
	if err != nil {
		logger.Error(err, "Failed to determine GVR for kind", "Kind", kind)
		return err
	}

	// Get the source resource
	srcResource, err := h.dynClient.Resource(gvr).Namespace(sourceNamespace).Get(ctx, name, metav1.GetOptions{})
	if err != nil {
		logger.Error(err, "Failed to get source resource")
		return err
	}

	// Prepare the resource for copying
	newResource := srcResource.DeepCopy()
	newResource.SetResourceVersion("")
	newResource.SetNamespace(targetNamespace)
	newResource.SetUID("")
	newResource.SetCreationTimestamp(metav1.Time{})
	newResource.SetGeneration(0)
	newResource.SetSelfLink("")
	newResource.SetManagedFields(nil)

	// Add owner reference
	ownerRefs := newResource.GetOwnerReferences()
	ownerRefs = append(ownerRefs, h.ownerRef)
	newResource.SetOwnerReferences(ownerRefs)

	// Remove status field if present
	unstructured.RemoveNestedField(newResource.Object, "status")

	// Add tracking labels
	labels := newResource.GetLabels()
	if labels == nil {
		labels = make(map[string]string)
	}
	labels["sharekube.dev/copied"] = "true"
	labels["sharekube.dev/source-namespace"] = sourceNamespace
	newResource.SetLabels(labels)

	// Create the resource in the target namespace
	_, err = h.dynClient.Resource(gvr).Namespace(targetNamespace).Create(ctx, newResource, metav1.CreateOptions{})
	if err != nil {
		logger.Error(err, "Failed to create resource in target namespace")
		return err
	}

	logger.Info("Successfully copied generic resource", "Kind", kind, "Name", name)
	return nil
}

// getGVRForKind returns the GroupVersionResource for a given kind
// This is a simplified implementation - in a real operator, you would use a discovery client
func getGVRForKind(kind string) (schema.GroupVersionResource, error) {
	// This is a simplified mapping - in a real implementation you would use the discovery client
	kindToGVR := map[string]schema.GroupVersionResource{
		"Deployment":  {Group: "apps", Version: "v1", Resource: "deployments"},
		"Service":     {Group: "", Version: "v1", Resource: "services"},
		"ConfigMap":   {Group: "", Version: "v1", Resource: "configmaps"},
		"Secret":      {Group: "", Version: "v1", Resource: "secrets"},
		"Pod":         {Group: "", Version: "v1", Resource: "pods"},
		"Ingress":     {Group: "networking.k8s.io", Version: "v1", Resource: "ingresses"},
		"StatefulSet": {Group: "apps", Version: "v1", Resource: "statefulsets"},
		"DaemonSet":   {Group: "apps", Version: "v1", Resource: "daemonsets"},
		"Job":         {Group: "batch", Version: "v1", Resource: "jobs"},
		"CronJob":     {Group: "batch", Version: "v1", Resource: "cronjobs"},
	}

	gvr, ok := kindToGVR[kind]
	if !ok {
		return schema.GroupVersionResource{}, fmt.Errorf("unknown kind: %s", kind)
	}

	return gvr, nil
}
